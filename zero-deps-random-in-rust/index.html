<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <meta property="og:type" content="website" />
      <meta property="og:url" content="https:&#x2F;&#x2F;blog.orhun.dev"/>
      <meta property="og:title" content="Orhun&#x27;s Blog" />
      <meta property="og:description" content="FOSS • Linux • Programming"/>
      <meta property="og:image" content="https:&#x2F;&#x2F;blog.orhun.dev/crow.png" />

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

      <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png">
      <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
      <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
      <link rel="manifest" href="/favicon/site.webmanifest">

      <script async defer data-website-id="56ca5ca7-ba9f-416e-8bee-a132c155d56b" src="https://umami.orhun.dev/umami.js"></script>

      <title>Orhun&#x27;s Blog</title>

      
        <link rel="alternate" type="application/rss+xml" title="RSS" href="https://blog.orhun.dev/rss.xml">
      

      
          <link rel="stylesheet" href="https://blog.orhun.dev/site.css">
      

      
      
    </head>

    <body class="hack dark main container">
        
    
        
                
                    <header>
                        <nav itemscope itemtype="http://schema.org/SiteNavigationElement">
                        
                            <a itemprop="url"
                               class=""
                               href="https:&#x2F;&#x2F;blog.orhun.dev">
                                <span itemprop="name">Home</span></a>
                        
                            <a itemprop="url"
                               class=""
                               href="https:&#x2F;&#x2F;blog.orhun.dev&#x2F;categories">
                                <span itemprop="name">Categories</span></a>
                        
                            <a itemprop="url"
                               class=""
                               href="https:&#x2F;&#x2F;github.com&#x2F;orhun&#x2F;personal-blog">
                                <span itemprop="name">Source</span></a>
                        
                            <a itemprop="url"
                               class=""
                               href="https:&#x2F;&#x2F;blog.orhun.dev&#x2F;rss.xml">
                                <span itemprop="name">RSS</span></a>
                        
                            <a itemprop="url"
                               class=""
                               href="https:&#x2F;&#x2F;orhun.dev">
                                <span itemprop="name">About</span></a>
                        
                        </nav>
                    </header>
                
            
    

<article itemscope itemtype="http://schema.org/BlogPosting">
    <header>
        <h1 itemprop="headline">Zero-dependency random number generation in Rust</h1>
        <span class="muted">
    <svg style="margin-bottom:-3px" class="i-clock" viewBox="0 0 32 32"
         width="16" height="16" fill="none" stroke="currentcolor"
         stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
        <circle cx="16" cy="16" r="14"/>
        <path d="M16 8 L16 16 20 20"/>
    </svg>
    <span>16 minute read</span>
    <svg style="margin-bottom: -3px" class="i-edit" viewBox="0 0 32 32"
         width="16" height="16" fill="none" stroke="currentcolor"
         stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
        <path d="M30 7 L25 2 5 22 3 29 10 27 Z M21 6 L26 11 Z M5 22 L10 27 Z"/>
    </svg>

    Published: 2023-01-03
</span>
    </header>
    <div itemprop="articleBody">
      <p>Let's investigate how to generate random numbers without external dependencies in Rust.</p>
<span id="continue-reading"></span><center>
<img alt="https://xkcd.com/221/" src="/xkcd221.png"/>
</center>
<br>
<p>Random numbers are very interesting. It feels like magic that we can generate such unpredictable entropies from deterministic sources.</p>
<p>But how does this happen? Before jumping into the generation of random numbers in Rust, let's understand the process of random number generation and how true randomness could never be created without special hardware.</p>
<h3 id="is-random-really-random">Is random really random?</h3>
<p>First of all, nothing is <em>truly</em> random when we consider the modern computers that we use on daily basis. This is because they are designed to be <em>deterministic</em>. What this means is that, given some initial state and an operation to perform, we can predict <em>exactly</em> how the machine will evolve. Simply put, for the given inputs <code>2</code> and <code>2</code>, we know the operation <code>2+2</code> will be outputting <code>4</code>. This makes total sense since we don't want to wonder what an addition will do, we just want to 'add'. However, this situation of certainty is incompatible with generating <em>truly</em> random numbers. From the definition of &quot;truly&quot;, we understand that there should be absolutely no way to predict it, regardless of the information we have. Although it seems impossible to predict a random number without certain quantum-mechanical processes, since it would require knowing the state of every molecule in the atmosphere, we still cannot say that what we generate is <em>truly</em> random.</p>
<p>But then, how do we generate 'random' numbers? Well, the answer is, in most cases, random is not so random. That's when <a href="https://en.wikipedia.org/wiki/Pseudorandomness">pseudorandomness</a> steps into the scene.</p>
<blockquote>
<p>Pseudo-random sequences typically exhibit statistical randomness while being generated by an entirely deterministic causal process.</p>
</blockquote>
<p>Cryptographically secure pseudorandom number generators (<strong>CSPRNG</strong>s) are very important in computing. Without them, we wouldn't have encryption algorithms. They <em>emulate</em> randomness by taking a statistically random sequence and using formulas to make it &quot;random enough&quot;.</p>
<p>The math behind PRNG might be complex but in general, it requires two steps:</p>
<ol>
<li>Provide the PRNG with an arbitrary <strong>seed</strong>.</li>
<li>Ask for the next random number.</li>
</ol>
<p>The <code>seed</code> is a starting point for creating random numbers. If the seed changes, the generated numbers also change. If the same seed is used, the same number is generated. The current timestamp is often used as a unique seed value. That precise time never occurs again, so a PRNG with that seed should produce a unique set of random numbers.</p>
<p>Now that we understand how random is not <em>truly</em> random and we can use pseudorandom with a seed to generate &quot;random enough&quot; numbers, let's see the ways of using PRNG in Rust and whether it is possible to do without extra dependencies. Unfortunately, there isn't a widely accepted and conventional way to generate random numbers by only using the core/standard library so we will have to be a little bit creative.</p>
<p>But hey, it will be fun!</p>
<hr />
<h3 id="using-rand">Using <a href="https://crates.io/crates/rand"><code>rand</code></a></h3>
<p>Probably the most straightforward of generating random numbers is using the <code>rand</code> crate.</p>
<p>Here are some <a href="https://rust-lang-nursery.github.io/rust-cookbook/algorithms/randomness.html">examples</a>:</p>
<pre data-lang="rs" style="background-color:#191919;color:#ffffff;" class="language-rs "><code class="language-rs" data-lang="rs"><span>use </span><span style="color:#cccccc;">rand::Rng;
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>main</span><span style="color:#cccccc;">() {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> rng </span><span>= </span><span style="color:#cccccc;">rand::thread_rng();
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> n1: </span><span style="color:#80d500;">u8 </span><span>=</span><span style="color:#cccccc;"> rng.</span><span style="color:#8aa6c1;">gen</span><span style="color:#cccccc;">();
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> n2: </span><span style="color:#80d500;">u16 </span><span>=</span><span style="color:#cccccc;"> rng.</span><span style="color:#8aa6c1;">gen</span><span style="color:#cccccc;">();
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// Prints 57, 31141, 1371217128, 1901352909, 0.5792015593471697, etc.
</span><span style="color:#cccccc;">    println!(</span><span style="color:#ffd700;">&quot;Random u8: </span><span style="color:#66ccff;">{}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">, n1);
</span><span style="color:#cccccc;">    println!(</span><span style="color:#ffd700;">&quot;Random u16: </span><span style="color:#66ccff;">{}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">, n2);
</span><span style="color:#cccccc;">    println!(</span><span style="color:#ffd700;">&quot;Random u32: </span><span style="color:#66ccff;">{}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">, rng.gen::&lt;</span><span style="color:#80d500;">u32</span><span style="color:#cccccc;">&gt;());
</span><span style="color:#cccccc;">    println!(</span><span style="color:#ffd700;">&quot;Random i32: </span><span style="color:#66ccff;">{}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">, rng.gen::&lt;</span><span style="color:#80d500;">i32</span><span style="color:#cccccc;">&gt;());
</span><span style="color:#cccccc;">    println!(</span><span style="color:#ffd700;">&quot;Random float: </span><span style="color:#66ccff;">{}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">, rng.gen::&lt;</span><span style="color:#80d500;">f64</span><span style="color:#cccccc;">&gt;());
</span><span style="color:#cccccc;">}
</span></code></pre>
<blockquote>
<p>Generates random numbers with help of random-number
generator <a href="https://docs.rs/rand/_/rand/trait.Rng.html"><code>rand::Rng</code></a> obtained via <a href="https://docs.rs/rand/_/rand/fn.thread_rng.html"><code>rand::thread_rng</code></a>. Each thread has an
initialized generator. Integers are uniformly distributed over the range of the
type, and floating point numbers are uniformly distributed from 0 up to but not
including 1.</p>
</blockquote>
<p>If we want to give a <em>seed</em> and generate the same number every time we run the program, then we can change the PRNG implementation as follows:</p>
<pre data-lang="rs" style="background-color:#191919;color:#ffffff;" class="language-rs "><code class="language-rs" data-lang="rs"><span>use </span><span style="color:#cccccc;">rand::{Rng, SeedableRng};
</span><span>use </span><span style="color:#cccccc;">rand_pcg::Pcg64;
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">const </span><span style="color:#66ccff;">SEED</span><span style="color:#cccccc;">: </span><span style="color:#80d500;">u64 </span><span>= </span><span style="color:#eddd5a;">42</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>main</span><span style="color:#cccccc;">() {
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// Uses PCG random number generator (XSL RR 128/64 (LCG) variant).
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> rng </span><span>= </span><span style="color:#cccccc;">Pcg64::seed_from_u64(</span><span style="color:#66ccff;">SEED</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// Prints &quot;Random u8: 9&quot; every time we run.
</span><span style="color:#cccccc;">    println!(</span><span style="color:#ffd700;">&quot;Random u8: </span><span style="color:#66ccff;">{}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">, rng.gen::&lt;</span><span style="color:#80d500;">u8</span><span style="color:#cccccc;">&gt;());
</span><span style="color:#cccccc;">}
</span></code></pre>
<p>However, we're still far from our objective, which is generating random numbers without dependencies. Even <code>rand</code> with default features has several transitive dependencies:</p>
<pre data-lang="sh" style="background-color:#191919;color:#ffffff;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#cccccc;">$ cargo tree
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">testapp v0.1.0
</span><span style="color:#cccccc;">└── rand v0.8.5
</span><span style="color:#cccccc;">    ├── libc v0.2.139
</span><span style="color:#cccccc;">    ├── rand_chacha v0.3.1
</span><span style="color:#cccccc;">    │   ├── ppv-lite86 v0.2.17
</span><span style="color:#cccccc;">    │   └── rand_core v0.6.4
</span><span style="color:#cccccc;">    │       └── getrandom v0.2.8
</span><span style="color:#cccccc;">    │           ├── cfg-if v1.0.0
</span><span style="color:#cccccc;">    │           └── libc v0.2.139
</span><span style="color:#cccccc;">    └── rand_core v0.6.4 (</span><span>*</span><span style="color:#cccccc;">)
</span></code></pre>
<p>Maybe we can look into reducing the transitive dependency count somehow before trying to achieve our 0-dependency goal.</p>
<p>I'm not sure how usable <code>rand</code> will be in this case, but we can simply remove the default features:</p>
<pre data-lang="toml" style="background-color:#191919;color:#ffffff;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#cccccc;">[dependencies]
</span><span style="color:#80d500;">rand </span><span style="color:#cccccc;">= { </span><span style="color:#80d500;">version </span><span style="color:#cccccc;">= </span><span style="color:#ffd700;">&quot;0.8.5&quot;</span><span style="color:#cccccc;">, </span><span style="color:#80d500;">default-features </span><span style="color:#cccccc;">= </span><span style="color:#80d500;">false </span><span style="color:#cccccc;">}
</span></code></pre>
<p>Then we have:</p>
<pre data-lang="sh" style="background-color:#191919;color:#ffffff;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#cccccc;">$ cargo tree
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">testapp v0.1.0
</span><span style="color:#cccccc;">└── rand v0.8.5
</span><span style="color:#cccccc;">    └── rand_core v0.6.4
</span></code></pre>
<p>Still not looking good? Well, luckily, we have an alternative crate to use.</p>
<hr />
<h3 id="using-fastrand">Using <a href="https://crates.io/crates/fastrand"><code>fastrand</code></a></h3>
<p><code>fastrand</code> is a simple and fast random number generator that uses <a href="https://github.com/wangyi-fudan/wyhash">wyhash</a>. This hash function is also simple and fast but not cryptographically secure.</p>
<p>So our previous examples with <code>rand</code> become the following:</p>
<pre data-lang="rs" style="background-color:#191919;color:#ffffff;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="color:#80d500;">fn </span><span>main</span><span style="color:#cccccc;">() {
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// Prints 119, 67, 233, etc.
</span><span style="color:#cccccc;">    println!(</span><span style="color:#ffd700;">&quot;Random u8: </span><span style="color:#66ccff;">{}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">, fastrand::u8(</span><span>..</span><span style="color:#cccccc;">));
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// Pick an arbitrary number as seed.
</span><span style="color:#cccccc;">    fastrand::seed(</span><span style="color:#eddd5a;">42</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// Prints e.g. 52 every time we run.
</span><span style="color:#cccccc;">    println!(</span><span style="color:#ffd700;">&quot;Random u8 with seed: </span><span style="color:#66ccff;">{}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">, fastrand::u8(</span><span>..</span><span style="color:#cccccc;">));
</span><span style="color:#cccccc;">}
</span></code></pre>
<p>How about our dependency count?</p>
<pre data-lang="sh" style="background-color:#191919;color:#ffffff;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#cccccc;">$ cargo tree
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">testapp v0.1.0
</span><span style="color:#cccccc;">└── fastrand v1.8.0
</span></code></pre>
<p>Well, it's good, but still not quite there. Technically, this approach is not 0-deps since <code>fastrand</code> itself is a dependency to our program.</p>
<p>Our goal is to have a single function that is simple enough for getting a random number every time we call it.</p>
<p>Hmm, let's see what we can do.</p>
<hr />
<h3 id="zero-dependency-random-number-generation"><strong>Zero-dependency Random Number Generation</strong></h3>
<p>There is more than one way to simulate entropy to generate random numbers and I will be mentioning the most suggested/interesting ways that I came across on <a href="https://www.reddit.com/r/rust/comments/c1az1t/random_numbers_without_crates/">Reddit</a> and <a href="https://users.rust-lang.org/t/random-number-without-using-the-external-crate/17260">Rust users forum</a>.</p>
<hr />
<h4 id="nanoseconds">Nanoseconds</h4>
<p>Here is the poor man's random number generator which only takes the nanoseconds of the current time:</p>
<pre data-lang="rs" style="background-color:#191919;color:#ffffff;" class="language-rs "><code class="language-rs" data-lang="rs"><span>use </span><span style="color:#cccccc;">std::error::Error;
</span><span>use </span><span style="color:#cccccc;">std::time::{SystemTime, </span><span style="color:#66ccff;">UNIX_EPOCH</span><span style="color:#cccccc;">};
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>main</span><span style="color:#cccccc;">() -&gt; </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;(), </span><span style="color:#8aa6c1;">Box</span><span style="color:#cccccc;">&lt;dyn Error&gt;&gt; {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> nanos </span><span>= </span><span style="color:#cccccc;">SystemTime::now().</span><span style="color:#8aa6c1;">duration_since</span><span style="color:#cccccc;">(</span><span style="color:#66ccff;">UNIX_EPOCH</span><span style="color:#cccccc;">)</span><span>?</span><span style="color:#cccccc;">.</span><span style="color:#8aa6c1;">subsec_nanos</span><span style="color:#cccccc;">();
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// Prints 864479511, 455850730, etc.
</span><span style="color:#cccccc;">    println!(</span><span style="color:#ffd700;">&quot;Random number: </span><span style="color:#66ccff;">{nanos}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">Ok</span><span style="color:#cccccc;">(())
</span><span style="color:#cccccc;">}
</span></code></pre>
<p>In this example, we take the current time which is expressed as duration since <a href="https://en.wikipedia.org/wiki/Unix_time">epoch</a>, and extract the number of nanoseconds elapsed in the current second. For example, if the current time is &quot;10:20:30.123456789&quot; then our 'random' number will be 123456789. The problem here is that the number will be always between zero and 1 billion. We need to use a bit of modulo arithmetic to get a random number in the desired range.</p>
<p>Well, this was suboptimal. Let's see what else we can do.</p>
<hr />
<h4 id="dev-urandom"><code>/dev/urandom</code></h4>
<blockquote>
<p>In Unix-like operating systems, <code>/dev/random</code> and <code>/dev/urandom</code> are special files that serve as cryptographically secure pseudorandom number generators. They allow access to environmental noise collected from device drivers and other sources.</p>
</blockquote>
<p>The difference between <code>/dev/random</code> and <code>/dev/urandom</code> is that <code>/dev/random</code> only returns random bytes within the estimated number of bits of noise in the entropy pool whereas <code>/dev/urandom</code> does not block waiting for more entropy. Thus <code>/dev/urandom</code> is theoretically vulnerable to a cryptographic attack on the algorithms used by the driver and less random than <code>/dev/random</code>. <code>/dev/random</code> is more suitable for very high-quality randomness applications such as one-time pad or key generation.</p>
<p>(If you would like to learn more about these magical files, see <a href="https://www.2uo.de/myths-about-urandom/">Myths about /dev/urandom</a>)</p>
<p>In our case, we don't want to wait for the entropy pool until additional environmental noise is gathered so we can use <code>/dev/urandom</code>.</p>
<p>(Edit after <a href="https://lobste.rs/s/9lfkmv/zero_dependency_random_number#c_wrwsw0">Foxboron's comment</a>: Apparently since the March of 2022 / Kernel 5.6, there is no difference between <code>/dev/random</code> and <code>/dev/urandom</code>. See <a href="https://www.theregister.com/2022/03/21/new_linux_kernel_has_improved/">this article</a>.)</p>
<p>An example usage of <code>/dev/urandom</code> which generates a random string is the following:</p>
<pre data-lang="sh" style="background-color:#191919;color:#ffffff;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#cccccc;">$ cat /dev/urandom </span><span>| </span><span style="color:#cccccc;">base64 </span><span>| </span><span style="color:#cccccc;">head</span><span style="font-style:italic;color:#8aa6c1;"> -c</span><span style="color:#cccccc;"> 10
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">66Dphl5MAh
</span></code></pre>
<p>In Rust, we can utilize <code>/dev/urandom</code> like so:</p>
<pre data-lang="rs" style="background-color:#191919;color:#ffffff;" class="language-rs "><code class="language-rs" data-lang="rs"><span>use </span><span style="color:#cccccc;">std::fs::File;
</span><span>use </span><span style="color:#cccccc;">std::io::{Read, </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">};
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>main</span><span style="color:#cccccc;">() -&gt; </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;()&gt; {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> rng </span><span>= </span><span style="color:#cccccc;">File::open(</span><span style="color:#ffd700;">&quot;/dev/urandom&quot;</span><span style="color:#cccccc;">)</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> buffer </span><span>= </span><span style="color:#cccccc;">[</span><span style="color:#eddd5a;">0</span><span style="color:#80d500;">u8</span><span style="color:#cccccc;">; </span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">];
</span><span style="color:#cccccc;">    rng.</span><span style="color:#8aa6c1;">read_exact</span><span style="color:#cccccc;">(</span><span>&amp;</span><span style="color:#80d500;">mut</span><span style="color:#cccccc;"> buffer)</span><span>?</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// Prints 92, 119, 122, etc.
</span><span style="color:#cccccc;">    println!(</span><span style="color:#ffd700;">&quot;Random u8: </span><span style="color:#66ccff;">{}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">, buffer[</span><span style="color:#eddd5a;">0</span><span style="color:#cccccc;">]);
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">Ok</span><span style="color:#cccccc;">(())
</span><span style="color:#cccccc;">}
</span></code></pre>
<p>Although this solution will work perfectly fine on Unix-based operating systems, we won't be able to run this on other operating systems such as Microsoft Windows since <code>/dev/urandom</code> doesn't exist.</p>
<p>But hey, we got our RNG without extra dependencies!</p>
<pre data-lang="sh" style="background-color:#191919;color:#ffffff;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#cccccc;">$ cargo tree
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">testapp v0.1.0
</span></code></pre>
<p>Interestingly enough, <a href="https://docs.rs/rand/latest/rand/rngs/struct.OsRng.html"><code>OsRng</code></a> implementation of <code>rand</code> also depends on this approach:</p>
<blockquote>
<p>The implementation is provided by the <a href="https://crates.io/crates/getrandom">getrandom</a> crate.</p>
</blockquote>
<p>And <code>getrandom</code> crate reads <code>/dev/urandom</code> under the hood:</p>
<blockquote>
<p>Uses <a href="https://man7.org/linux/man-pages/man2/getrandom.2.html">getrandom</a> system call if available, otherwise <code>/dev/urandom</code> after successfully polling <code>/dev/random</code>.</p>
</blockquote>
<p>Wait, did I just read &quot;getrandom system call&quot;? I wonder if we can we utilize that for generating random numbers.</p>
<hr />
<h4 id="getrandom-2"><code>getrandom(2)</code></h4>
<pre data-lang="c" style="background-color:#191919;color:#ffffff;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#80d500;">#include </span><span style="color:#ffd700;">&lt;sys/random.h&gt;
</span><span style="color:#cccccc;">
</span><span style="color:#8aa6c1;">ssize_t </span><span>getrandom</span><span style="color:#cccccc;">(</span><span style="color:#80d500;">void </span><span>*</span><span style="font-style:italic;color:#8aa6c1;">buf</span><span style="color:#cccccc;">, </span><span style="color:#8aa6c1;">size_t </span><span style="font-style:italic;color:#8aa6c1;">buflen</span><span style="color:#cccccc;">, </span><span style="color:#80d500;">unsigned int </span><span style="font-style:italic;color:#8aa6c1;">flags</span><span style="color:#cccccc;">);
</span></code></pre>
<blockquote>
<p>The <code>getrandom()</code> system call fills the buffer pointed to by <code>buf</code> with up to <code>buflen</code> random bytes.
These bytes can be used to <strong>seed</strong> user-space random number generators or for cryptographic purposes.
By default, <code>getrandom()</code> draws entropy from the urandom source (i.e., the same source as the <code>/dev/urandom</code> device).
This behavior can be changed via the <code>flags</code> argument.</p>
</blockquote>
<p>In order to use this system call in Rust, we need to define own our extern function or use the <a href="https://crates.io/crates/libc">libc</a> crate since Unix systems expose the syscalls through <code>libc</code>.</p>
<pre data-lang="rs" style="background-color:#191919;color:#ffffff;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="background-color:#171717;color:#616161;">// https://man7.org/linux/man-pages/man2/getrandom.2.html
</span><span style="color:#cccccc;">#[cfg(not(target_os </span><span>= </span><span style="color:#ffd700;">&quot;windows&quot;</span><span style="color:#cccccc;">))]
</span><span style="color:#cccccc;">#[link(name </span><span>= </span><span style="color:#ffd700;">&quot;c&quot;</span><span style="color:#cccccc;">)]
</span><span>extern </span><span style="color:#ffd700;">&quot;C&quot; </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">fn </span><span>getrandom</span><span style="color:#cccccc;">(</span><span style="font-style:italic;color:#8aa6c1;">buf</span><span style="color:#cccccc;">: </span><span style="color:#80d500;">*const u8</span><span style="color:#cccccc;">, </span><span style="font-style:italic;color:#8aa6c1;">buflen</span><span style="color:#cccccc;">: </span><span style="color:#80d500;">usize</span><span style="color:#cccccc;">, </span><span style="font-style:italic;color:#8aa6c1;">flags</span><span style="color:#cccccc;">: </span><span style="color:#80d500;">u32</span><span style="color:#cccccc;">) -&gt; </span><span style="color:#80d500;">usize</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>main</span><span style="color:#cccccc;">() {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> buffer </span><span>= </span><span style="color:#cccccc;">[</span><span style="color:#eddd5a;">0</span><span style="color:#80d500;">u8</span><span style="color:#cccccc;">; </span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">];
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">unsafe </span><span style="color:#cccccc;">{ </span><span style="color:#8aa6c1;">getrandom</span><span style="color:#cccccc;">(buffer.</span><span style="color:#8aa6c1;">as_ptr</span><span style="color:#cccccc;">(), </span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">, </span><span style="color:#eddd5a;">2</span><span style="color:#cccccc;">) };
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// Prints 78, 51, 241, etc.
</span><span style="color:#cccccc;">    println!(</span><span style="color:#ffd700;">&quot;Seed: </span><span style="color:#66ccff;">{:?}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">, buffer[</span><span style="color:#eddd5a;">0</span><span style="color:#cccccc;">]);
</span><span style="color:#cccccc;">}
</span></code></pre>
<p>In our example, we defined an extern function with the same name as our system call (<code>getrandom</code>) to link to C library on the system so that we can interoperate with the C code. When we run this program, we can see that random seeds are generated using the <code>getrandom()</code> system call.</p>
<p>The downside of this approach is that it will only work on systems that <code>getrandom()</code> system call exists and it is inescapably using <code>unsafe</code> code.</p>
<p>But yeah, it is 0-deps on the surface, except the system call itself.</p>
<hr />
<h4 id="rand-srand"><code>rand()</code> / <code>srand()</code></h4>
<pre data-lang="c" style="background-color:#191919;color:#ffffff;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#80d500;">#include </span><span style="color:#ffd700;">&lt;stdlib.h&gt;
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">int </span><span>rand</span><span style="color:#cccccc;">(</span><span style="color:#80d500;">void</span><span style="color:#cccccc;">);
</span><span style="color:#80d500;">void </span><span>srand</span><span style="color:#cccccc;">(</span><span style="color:#80d500;">unsigned int </span><span style="font-style:italic;color:#8aa6c1;">seed</span><span style="color:#cccccc;">);
</span></code></pre>
<p>Another external way of generating random numbers is to call the C library function <a href="https://www.ibm.com/docs/en/zos/2.2.0?topic=functions-rand-generate-random-number">rand()</a>. Along with <a href="https://www.ibm.com/docs/en/zos/2.2.0?topic=functions-srand-set-seed-rand-function">srand()</a>, you can set the seed to use for a pseudorandom number generator. If <code>srand()</code> is not called, the <code>rand()</code> seed is set as if <code>srand(1)</code> was called at the program start.</p>
<p>We can implement this in Rust similar to <code>getrandom()</code> system call. For the seed, we can use the <a href="https://blog.orhun.dev/zero-deps-random-in-rust/#nanoseconds">nanoseconds</a>:</p>
<pre data-lang="rs" style="background-color:#191919;color:#ffffff;" class="language-rs "><code class="language-rs" data-lang="rs"><span>use </span><span style="color:#cccccc;">std::error::Error;
</span><span>use </span><span style="color:#cccccc;">std::time::{SystemTime, </span><span style="color:#66ccff;">UNIX_EPOCH</span><span style="color:#cccccc;">};
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">#[link(name </span><span>= </span><span style="color:#ffd700;">&quot;c&quot;</span><span style="color:#cccccc;">)]
</span><span>extern </span><span style="color:#ffd700;">&quot;C&quot; </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">fn </span><span>rand</span><span style="color:#cccccc;">() -&gt; </span><span style="color:#80d500;">i32</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">fn </span><span>srand</span><span style="color:#cccccc;">(</span><span style="font-style:italic;color:#8aa6c1;">seed</span><span style="color:#cccccc;">: </span><span style="color:#80d500;">u32</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>main</span><span style="color:#cccccc;">() -&gt; </span><span style="color:#8aa6c1;">Result</span><span style="color:#cccccc;">&lt;(), </span><span style="color:#8aa6c1;">Box</span><span style="color:#cccccc;">&lt;dyn Error&gt;&gt; {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> seed </span><span>= </span><span style="color:#cccccc;">SystemTime::now().</span><span style="color:#8aa6c1;">duration_since</span><span style="color:#cccccc;">(</span><span style="color:#66ccff;">UNIX_EPOCH</span><span style="color:#cccccc;">)</span><span>?</span><span style="color:#cccccc;">.</span><span style="color:#8aa6c1;">subsec_nanos</span><span style="color:#cccccc;">();
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">unsafe </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">        </span><span style="color:#8aa6c1;">srand</span><span style="color:#cccccc;">(seed);
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">        </span><span style="background-color:#171717;color:#616161;">// Prints 1741856104, 1321400234, etc.
</span><span style="color:#cccccc;">        println!(</span><span style="color:#ffd700;">&quot;Random number: </span><span style="color:#66ccff;">{}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">, </span><span style="color:#8aa6c1;">rand</span><span style="color:#cccccc;">());
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="color:#8aa6c1;">Ok</span><span style="color:#cccccc;">(())
</span><span style="color:#cccccc;">}
</span></code></pre>
<p>This has the same disadvantages as <code>getrandom</code>, it requires the C library for linking and has <code>unsafe</code> code.</p>
<hr />
<h4 id="getauxval-3"><code>getauxval(3)</code></h4>
<pre data-lang="c" style="background-color:#191919;color:#ffffff;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#80d500;">#include </span><span style="color:#ffd700;">&lt;sys/auxv.h&gt;
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">unsigned long </span><span>getauxval</span><span style="color:#cccccc;">(</span><span style="color:#80d500;">unsigned long </span><span style="font-style:italic;color:#8aa6c1;">type</span><span style="color:#cccccc;">);
</span></code></pre>
<blockquote>
<p>The <a href="https://man7.org/linux/man-pages/man3/getauxval.3.html">getauxval()</a> function retrieves values from the auxiliary vector, a mechanism that the kernel's ELF binary loader uses to pass certain information to user space when a program is executed.</p>
<p>Each entry in the auxiliary vector consists of a pair of values: a type that identifies what this entry represents, and a value for that type. Given the argument <code>type</code>, <code>getauxval()</code> returns the corresponding value.</p>
</blockquote>
<pre data-lang="rs" style="background-color:#191919;color:#ffffff;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="background-color:#171717;color:#616161;">// https://man7.org/linux/man-pages/man3/getauxval.3.html
</span><span style="color:#cccccc;">#[cfg(not(target_os </span><span>= </span><span style="color:#ffd700;">&quot;windows&quot;</span><span style="color:#cccccc;">))]
</span><span style="color:#cccccc;">#[link(name </span><span>= </span><span style="color:#ffd700;">&quot;c&quot;</span><span style="color:#cccccc;">)]
</span><span>extern </span><span style="color:#ffd700;">&quot;C&quot; </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">fn </span><span>getauxval</span><span style="color:#cccccc;">(r#</span><span style="font-style:italic;color:#8aa6c1;">type</span><span style="color:#cccccc;">: </span><span style="color:#80d500;">u64</span><span style="color:#cccccc;">) -&gt; </span><span style="color:#80d500;">u64</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>main</span><span style="color:#cccccc;">() {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> rnd </span><span>= </span><span style="color:#80d500;">unsafe </span><span style="color:#cccccc;">{ </span><span>*</span><span style="color:#cccccc;">(</span><span style="color:#8aa6c1;">getauxval</span><span style="color:#cccccc;">(</span><span style="color:#eddd5a;">25</span><span style="color:#cccccc;">) </span><span>as </span><span style="color:#80d500;">*const </span><span style="color:#cccccc;">[</span><span style="color:#80d500;">u8</span><span style="color:#cccccc;">; </span><span style="color:#eddd5a;">1</span><span style="color:#cccccc;">]) };
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// Prints 206, 120, 76, etc.
</span><span style="color:#cccccc;">    println!(</span><span style="color:#ffd700;">&quot;Random number: </span><span style="color:#66ccff;">{:?}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">, rnd[</span><span style="color:#eddd5a;">0</span><span style="color:#cccccc;">]);
</span><span style="color:#cccccc;">}
</span></code></pre>
<p>The <code>type</code> argument of <code>getauxval()</code> (&quot;25&quot; in this case) is defined in <code>libc</code> as follows:</p>
<pre data-lang="rs" style="background-color:#191919;color:#ffffff;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="background-color:#171717;color:#616161;">// The address of sixteen bytes containing a random value.
</span><span style="color:#80d500;">pub const </span><span style="color:#66ccff;">AT_RANDOM</span><span style="color:#cccccc;">: ::</span><span style="color:#80d500;">c_ulong </span><span>= </span><span style="color:#eddd5a;">25</span><span style="color:#cccccc;">;
</span></code></pre>
<p>This solution was originally suggested by <a href="https://www.reddit.com/r/rust/comments/102ar8c/comment/j2s7h8l/?utm_source=share&amp;utm_medium=web2x&amp;context=3">mina86ng</a> on Reddit.</p>
<hr />
<h4 id="raw-pointers">Raw pointers</h4>
<p>Let's go for our last attempt.</p>
<p>The bottom line is, if we allocate something, take the pointer to it, retrieve the address, and cast it to an integer; we will get a random number. The address in the memory is not totally random, but probably random enough to do stuff™.</p>
<pre data-lang="rs" style="background-color:#191919;color:#ffffff;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="color:#80d500;">fn </span><span>main</span><span style="color:#cccccc;">() {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> pointer </span><span>= </span><span style="color:#8aa6c1;">Box</span><span style="color:#cccccc;">::into_raw(</span><span style="color:#8aa6c1;">Box</span><span style="color:#cccccc;">::new(</span><span style="color:#eddd5a;">42</span><span style="color:#cccccc;">));
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// Prints 94560791661472, 94796207967136, etc.
</span><span style="color:#cccccc;">    println!(</span><span style="color:#ffd700;">&quot;Random number: </span><span style="color:#66ccff;">{}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">, pointer </span><span>as </span><span style="color:#80d500;">usize</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">}
</span></code></pre>
<p>The problem with that approach is, apart from using a memory address for a random number, the numbers are always even since they are a memory address aligned to the size of an integer.</p>
<p>Also, the code above has memory leaks due to not handling the memory after calling <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.into_raw"><code>Box::into_raw</code></a>.</p>
<pre data-lang="sh" style="background-color:#191919;color:#ffffff;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#cccccc;">$ valgrind</span><span style="font-style:italic;color:#8aa6c1;"> -v</span><span style="color:#cccccc;"> target/debug/testapp
</span><span style="color:#cccccc;">
</span><span>=</span><span style="color:#ffd700;">=985609== </span><span style="color:#cccccc;">HEAP SUMMARY:
</span><span>=</span><span style="color:#ffd700;">=985609==     </span><span style="color:#cccccc;">in use at exit: 4 bytes in 1 blocks
</span><span>=</span><span style="color:#ffd700;">=985609==   </span><span style="color:#cccccc;">total heap usage: 12 allocs, 11 frees, 3,185 bytes allocated
</span><span>=</span><span style="color:#ffd700;">=985609==
</span><span>=</span><span style="color:#ffd700;">=985609== </span><span style="color:#cccccc;">Searching for pointers to 1 not-freed blocks
</span><span>=</span><span style="color:#ffd700;">=985609== </span><span style="color:#cccccc;">Checked 110,200 bytes
</span><span>=</span><span style="color:#ffd700;">=985609==
</span><span>=</span><span style="color:#ffd700;">=985609== </span><span style="color:#cccccc;">LEAK SUMMARY:
</span><span>=</span><span style="color:#ffd700;">=985609==    </span><span style="color:#cccccc;">definitely lost: 4 bytes in 1 blocks
</span><span>=</span><span style="color:#ffd700;">=985609==    </span><span style="color:#cccccc;">indirectly lost: 0 bytes in 0 blocks
</span><span>=</span><span style="color:#ffd700;">=985609==      </span><span style="color:#cccccc;">possibly lost: 0 bytes in 0 blocks
</span><span>=</span><span style="color:#ffd700;">=985609==    </span><span style="color:#cccccc;">still reachable: 0 bytes in 0 blocks
</span><span>=</span><span style="color:#ffd700;">=985609==         </span><span style="color:#cccccc;">suppressed: 0 bytes in 0 blocks
</span></code></pre>
<p>So we can edit the code as follows for manual cleanup by explicitly running the destructor and deallocating the memory:</p>
<pre data-lang="rs" style="background-color:#191919;color:#ffffff;" class="language-rs "><code class="language-rs" data-lang="rs"><span>use </span><span style="color:#cccccc;">std::alloc::{dealloc, Layout};
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>main</span><span style="color:#cccccc;">() {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> pointer </span><span>= </span><span style="color:#8aa6c1;">Box</span><span style="color:#cccccc;">::into_raw(</span><span style="color:#8aa6c1;">Box</span><span style="color:#cccccc;">::new(</span><span style="color:#eddd5a;">42</span><span style="color:#cccccc;">));
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// Prints 94560791661472, 94796207967136, etc.
</span><span style="color:#cccccc;">    println!(</span><span style="color:#ffd700;">&quot;Random number: </span><span style="color:#66ccff;">{}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">, pointer </span><span>as </span><span style="color:#80d500;">usize</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">unsafe </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">        std::ptr::drop_in_place(pointer);
</span><span style="color:#cccccc;">        </span><span style="color:#8aa6c1;">dealloc</span><span style="color:#cccccc;">(pointer </span><span>as </span><span style="color:#80d500;">*mut u8</span><span style="color:#cccccc;">, Layout::new::&lt;</span><span style="color:#80d500;">u32</span><span style="color:#cccccc;">&gt;());
</span><span style="color:#cccccc;">    }
</span><span style="color:#cccccc;">}
</span></code></pre>
<pre data-lang="sh" style="background-color:#191919;color:#ffffff;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#cccccc;">$ valgrind</span><span style="font-style:italic;color:#8aa6c1;"> -v</span><span style="color:#cccccc;"> target/debug/testapp
</span><span style="color:#cccccc;">
</span><span>=</span><span style="color:#ffd700;">=986501== </span><span style="color:#cccccc;">HEAP SUMMARY:
</span><span>=</span><span style="color:#ffd700;">=986501==     </span><span style="color:#cccccc;">in use at exit: 0 bytes in 0 blocks
</span><span>=</span><span style="color:#ffd700;">=986501==   </span><span style="color:#cccccc;">total heap usage: 12 allocs, 12 frees, 3,185 bytes allocated
</span><span>=</span><span style="color:#ffd700;">=986501==
</span><span>=</span><span style="color:#ffd700;">=986501== </span><span style="color:#cccccc;">All heap blocks were freed</span><span> --</span><span style="color:#cccccc;"> no leaks are possible
</span></code></pre>
<p>Yay! No leaks.</p>
<p>But... Damn. Why are we even dealing with this? Let's just use a raw pointer via <code>*const T</code>:</p>
<pre data-lang="rs" style="background-color:#191919;color:#ffffff;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="color:#80d500;">fn </span><span>main</span><span style="color:#cccccc;">() {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> num </span><span>= </span><span style="color:#eddd5a;">42</span><span style="color:#80d500;">u8</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> address </span><span>= &amp;</span><span style="color:#cccccc;">num </span><span>as </span><span style="color:#80d500;">*const u8</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// Prints 140736885020951, 140731585258103, etc.
</span><span style="color:#cccccc;">    println!(</span><span style="color:#ffd700;">&quot;</span><span style="color:#66ccff;">{}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">, address </span><span>as </span><span style="color:#80d500;">usize</span><span style="color:#cccccc;">);
</span><span style="color:#cccccc;">}
</span></code></pre>
<p>In this example, obtaining an address like this is completely safe. But we will need to use <code>unsafe</code> Rust if we want to do anything with it.</p>
<p>However, thanks to <a href="https://lobste.rs/s/9lfkmv/zero_dependency_random_number#c_kwmq2d">spacejam's comment</a>, we can see that it is not a good entropy source.</p>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">ASLR</a> (address space layout randomization) implementations tend to have weaknesses that manifest in ways that might not be obvious just looking at the scrambled output.</p>
</blockquote>
<pre data-lang="rs" style="background-color:#191919;color:#ffffff;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="color:#80d500;">fn </span><span>main</span><span style="color:#cccccc;">() {
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// Prints:
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// 0x000055a7a8b55410
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// 0x000055a4d561b410
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// 0x000055c683ec3410
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// 0x0000560f7b369410
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// etc.
</span><span style="color:#cccccc;">    dbg![main </span><span>as </span><span style="color:#80d500;">*const u8</span><span style="color:#cccccc;">];
</span><span style="color:#cccccc;">}
</span></code></pre>
<p>More succinctly:</p>
<pre data-lang="rs" style="background-color:#191919;color:#ffffff;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="color:#80d500;">fn </span><span>main</span><span style="color:#cccccc;">() {
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// Prints:
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">//
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// 1088
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// 1088
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// 1088
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// etc.
</span><span style="color:#cccccc;">    dbg![main </span><span>as </span><span style="color:#80d500;">*const u8 </span><span>as </span><span style="color:#80d500;">usize </span><span>% </span><span style="color:#eddd5a;">4096</span><span style="color:#cccccc;">];
</span><span style="color:#cccccc;">}
</span></code></pre>
<blockquote>
<p>While the stack in the previous example gets a different distribution due to its reliance on a stack frame’s placement in the address space, there are still sharp edges about every system’s ASLR implementation that it’s kind of frustrating that only exploit writers seem to pay any attention to, despite their significant impacts on performance.</p>
</blockquote>
<p>Another comment about how bad this approach would be is the following:</p>
<blockquote>
<p>The &quot;randomness&quot; comes from ASLR, which is <em>extremely</em> limited on 32b systems (8~16 bits of entropy). 64b systems have more room, but it's still absolutely awful as an rng, IIRC on x86_64 Linux it defaults to 28 bits (you can check <code>/proc/sys/vm/mmap_rnd_bits</code> for the value on your system, last I checked it could be set from 28 to 32 inclusive).</p>
<p>If the allocator uses brk instead of mmap, it's worse, you get 13 bits of entropy out of the brk ASLR. Or less if you use huge pages.</p>
<ul>
<li><a href="https://www.reddit.com/user/masklinn/">masklinn</a> on Reddit</li>
</ul>
</blockquote>
<hr />
<h4 id="std-collections-hash-map-randomstate"><code>std::collections::hash_map::RandomState</code></h4>
<p>This solution was suggested by several people after I shared the blog post so thanks!</p>
<p>Simply, we can use the <a href="https://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html">RandomState</a> of the standard library's HashMap implementation and generate a random number from the hasher:</p>
<pre data-lang="rs" style="background-color:#191919;color:#ffffff;" class="language-rs "><code class="language-rs" data-lang="rs"><span>use </span><span style="color:#cccccc;">std::collections::hash_map::RandomState;
</span><span>use </span><span style="color:#cccccc;">std::hash::{BuildHasher, Hasher};
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">fn </span><span>main</span><span style="color:#cccccc;">() {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let</span><span style="color:#cccccc;"> hasher </span><span>= </span><span style="color:#cccccc;">RandomState::new().</span><span style="color:#8aa6c1;">build_hasher</span><span style="color:#cccccc;">();
</span><span style="color:#cccccc;">
</span><span style="color:#cccccc;">    </span><span style="background-color:#171717;color:#616161;">// Prints 938021294471563529, 17633394154785464152, etc.
</span><span style="color:#cccccc;">    println!(</span><span style="color:#ffd700;">&quot;Random number: </span><span style="color:#66ccff;">{}</span><span style="color:#ffd700;">&quot;</span><span style="color:#cccccc;">, hasher.</span><span style="color:#8aa6c1;">finish</span><span style="color:#cccccc;">());
</span><span style="color:#cccccc;">}
</span></code></pre>
<p>It probably makes more sense to use these random values as seed rather than random number. For example, we can have the following function for generating a random seed and combine it with a suggestion by <a href="https://github.com/matklad/config/blob/b8ea0aad0f86d4575651a390a3c7aefb63229774/templates/snippets/src/lib.rs#L28L42">matklad</a>:</p>
<pre data-lang="rs" style="background-color:#191919;color:#ffffff;" class="language-rs "><code class="language-rs" data-lang="rs"><span>use </span><span style="color:#cccccc;">std::collections::hash_map::RandomState;
</span><span>use </span><span style="color:#cccccc;">std::hash::{BuildHasher, Hasher};
</span><span style="color:#cccccc;">
</span><span style="color:#80d500;">pub fn </span><span>random_seed</span><span style="color:#cccccc;">() -&gt; </span><span style="color:#80d500;">u64 </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">    RandomState::new().</span><span style="color:#8aa6c1;">build_hasher</span><span style="color:#cccccc;">().</span><span style="color:#8aa6c1;">finish</span><span style="color:#cccccc;">()
</span><span style="color:#cccccc;">}
</span><span style="color:#cccccc;">
</span><span style="background-color:#171717;color:#616161;">// Pseudorandom number generator from the &quot;Xorshift RNGs&quot; paper by George Marsaglia.
</span><span style="background-color:#171717;color:#616161;">//
</span><span style="background-color:#171717;color:#616161;">// https://github.com/rust-lang/rust/blob/1.55.0/library/core/src/slice/sort.rs#L559-L573
</span><span style="color:#80d500;">pub fn </span><span>random_numbers</span><span style="color:#cccccc;">() -&gt; impl </span><span style="color:#8aa6c1;">Iterator</span><span style="color:#cccccc;">&lt;Item = </span><span style="color:#80d500;">u32</span><span style="color:#cccccc;">&gt; {
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">let mut</span><span style="color:#cccccc;"> random </span><span>= </span><span style="color:#eddd5a;">92</span><span style="color:#80d500;">u32</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">    std::iter::repeat_with(</span><span style="color:#80d500;">move </span><span>|| </span><span style="color:#cccccc;">{
</span><span style="color:#cccccc;">        random </span><span>^=</span><span style="color:#cccccc;"> random </span><span>&lt;&lt; </span><span style="color:#eddd5a;">13</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">        random </span><span>^=</span><span style="color:#cccccc;"> random </span><span>&gt;&gt; </span><span style="color:#eddd5a;">17</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">        random </span><span>^=</span><span style="color:#cccccc;"> random </span><span>&lt;&lt; </span><span style="color:#eddd5a;">5</span><span style="color:#cccccc;">;
</span><span style="color:#cccccc;">        random
</span><span style="color:#cccccc;">    })
</span><span style="color:#cccccc;">}
</span></code></pre>
<hr />
<h3 id="final-thoughts">Final thoughts</h3>
<p>Of course, there might be other ways to generate a random number without dependencies. This article aims to show the simplest ways without going too much into mathematical details.</p>
<p>Thanks to everyone who commented in the <a href="https://users.rust-lang.org/t/random-number-without-using-the-external-crate/17260/18">forums thread</a>, it was definitely helpful to read all the replies!</p>
<p>Let me know via the comments below if there are any other cool ways for generating random numbers.</p>
<p>See you next time! 🐻</p>

    </div>

    
        <footer>
            <hr>
            <p>
                
                    Published by Orhun Parmaksız
                
                
                    
                    in <a href="https://blog.orhun.dev/categories/guides/">Guides</a>
                
                
            </p>
            
            
            <iframe src="https://github.com/sponsors/orhun/button" title="Sponsor @orhun" height="35" width="116" style="border: 0;"></iframe>
            <script src="https://utteranc.es/client.js"
                    repo="orhun/personal-blog"
                    issue-term="url"
                    label="comments"
                    theme="github-dark"
                    crossorigin="anonymous"
                    async>
            </script>
        </footer>
    
</article>


    </body>

</html>
